<!DOCTYPE html>
<html>

<head>
  <title>csbase week3</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, Helvetica, sans-serif;
    }


    header {
      width: 100%;
      height: 10%;
      text-align: center;
      font-size: 33px;
    }

    nav {
      width: 15%;
      height: 800%;
      float: left;
    }

    section {
      width: 80%;
      height: 1650%;
      float: left;

    }

    aside {
      width: 5%;
      height: 800%;
      float: left;
    }

    footer {
      width: 100%;
      height: 10%;
      clear: both;
    }

    pre {
      word-wrap: break-word;
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 30px;
    }

    ul {
      font-size: 17px;
    }

    li {
      padding-bottom: 2px;
    }

    .tag {
      font-size: 19px;
      font-weight: bolder;
    }
  </style>
</head>

<body>
  <header>
    <br>Week3_1

  </header>
  <nav>
    <ul>
      <li><a href="#GO_language">GO 언어</a></li>
      <li><a href="#RUST_language">RUST 언어</a></li>
      <li><a href="#gdb">gdb</a></li>
      <li><a href="#scanf_string_matching">scanf의 문자열 매칭</a></li>
      <li><a href="#C_header_files">C언어 헤더 파일</a></li>
      <li><a href="#fopen_freopen">fopen과 freopen</a></li>
      <li><a href="#C_plus_plus_cout">C++의 cout</a></li>
      <li><a href="#Cin_printf_difference">cin과 C의 printf, scanf와의 차이</a></li>
      <li><a href="#pointer_reference_difference">포인터(*)와 참조(&)의 차이</a></li>
      <li><a href="#function_pointer_lambda">함수 포인터와 람다(익명) 함수</a></li>
      <li><a href="#callback_hell">콜백 함수와 콜백 지옥</a></li>
    </ul>
  </nav>
  <section>
    <hr>
    <br>
    <div id="GO_language">
      <a class="tag">GO 언어</a>
      <pre>
        GO 언어, 또는 Golang은 구글에서 개발한 오픈 소스 프로그래밍 언어입니다.
        Go는 2007년부터 개발이 시작되었고, 2009년에 공개되었습니다.
        Go의 주요 개발자는 로버트 그리즈머(Robert Griesemer), 롭 파이크(Rob Pike) 및 켄 톰프슨(Ken Thompson)이며, 이들은 모두 구글에 소속되어 있습니다.

        GO 언어의 주요 특징은 다음과 같습니다:
        1. 간결한 문법: Go는 C와 유사한 문법을 가지면서도, 보다 간결한 스타일을 추구합니다. 복잡한 상속 체계나 다중 상속을 사용하지 않고, 인터페이스를 사용하여 코드의 재사용성을 높입니다.
        2. 동시성 지원: Go는 길로틴(Goroutine)이라는 경량 스레드를 사용하여 동시성을 지원합니다. 채널(Channel)을 통해 길로틴간의 통신 및 동기화를 관리할 수 있습니다.
        3. 강한 정적 타입: Go는 정적 타입 시스템을 사용하여, 변수와 함수의 높은 수준의 타입 안전성을 제공합니다.
        4. 가비지 컬렉션: Go는 가비지 컬렉션(Garbage Collection)을 통해 메모리 관리를 자동화합니다.
        5. 빠른 컴파일 속도: Go는 빠른 컴파일 속도를 가집니다. 이로 인해 개발자의 생산성이 향상되고, 작은 변경사항에도 빠르게 반응할 수 있습니다.
        6. 크로스 컴파일: Go는 다양한 플랫폼에 대한 크로스 컴파일을 지원하며, 손쉬운 배포가 가능합니다.
        7. 표준 라이브러리: Go는 광범위한 표준 라이브러리를 제공하며, 입출력, 데이터 변환, 네트워크 프로그래밍, 암호화 등 다양한 기능을 이용할 수 있습니다.
        
        GO 언어는 웹 서버, 네트워크 프로그래밍, 운영 체제 개발, 커맨드 라인 도구, 마이크로서비스 등 다양한 분야에서 사용되고 있습니다.
        </pre>
    </div>
    <div id="RUST_language">
      <a class="tag">RUST 언어</a>
      <pre>
        Rust는 시스템 프로그래밍 언어로 주로 메모리 안정성과 성능에 초점을 맞춘 개발이 진행됩니다.
        Mozilla Research에서 처음 개발되었고, C++와 같은 수준의 시스템 프로그래밍 능력을 가지면서 메모리 관리 문제를 최소화하는 것을 목표로 하고 있습니다.

        Rust의 주요 특징은 다음과 같습니다:
        1. 안전성: Rust는 메모리 안전성을 보장하며 일반적으로 C++에서 발생하는 메모리 문제를 방지합니다. 이를 위해 Rust는 컴파일 시간에 소유권 및 참조 허용 체계를 사용하여 런타임 비용 없이 안전성을 확인합니다.
        2. 성능: Rust는 강력한 정적 타이핑 및 LLVM을 기반으로 한 최적화를 사용하여 뛰어난 성능을 제공합니다. 또한 Rust 프로그램은 C와 C++과 호환되어 쉽게 시스템에 통합할 수 있습니다.
        3. 병렬성: Rust는 데이터 레이스와 같은 병렬 프로그래밍에 관련된 일반적인 버그를 방지하기 위한 동시성 모델을 제공합니다.
        4. 확장성: Rust 컴파일러는 매크로 시스템과 익스트러션을 제공하여 코드의 재사용 및 확장을 용이하게 합니다.
        5. 커뮤니티: Rust는 매우 활동적인 개발자 커뮤니티를 갖고 있으며 매년 Rust 프로젝트에 대한 개선 및 기능 추가를 수행하고 있습니다.
           Rust는 여러 연속 된 년도 동안 Stack Overflow 설문 조사에서 "가장 사랑받는 프로그래밍 언어" 상을 받았습니다.
        
        Rust는 웹 어셈블리, 임베디드 시스템, 운영체제 개발, 게임 엔진, 네트워크 서비스 등 많은 애플리케이션에서 사용되고 있습니다.
        일부 큰 프로젝트로는 Servo 웹 엔진, Redox 운영체제, 그리고 Microsoft가 개발 중인 하이퍼프로텍트 프레임워크 등이 있습니다.
      </pre>
    </div>
    <div id="gdb">
      <a class="tag">gdb</a>
      <pre>
        GDB(GNU Debugger)는 GNU 프로젝트에서 개발한 소스 레벨의 디버깅 도구입니다.
        GDB는 주로 C, C++, Fortran, Pascal, Go, Rust, Ada 등의 프로그래밍 언어를 지원하며, 디버깅을 위한 여러 플랫폼을 지원합니다. 

        GDB를 사용하면 사용자들은 다음과 같은 작업을 수행할 수 있습니다:
        1. 프로그램의 실행을 시작, 중지 또는 재시작할 수 있습니다.
        2. 프로그램이 특정 조건에 도달할 때 중단점(breakpoints)을 설정하여 멈출 수 있습니다.
        3. 프로그램이 오류 상태에서 실행되거나 중지되었을 때, 메모리 및 레지스터의 내용을 검사할 수 있습니다.
        4. 실시간으로 변수 및 데이터 구조의 값을 수정할 수 있습니다.
        5. 프로그램의 실행 흐름을 단계적으로 진행하고, 함수 호출 등을 추적할 수 있습니다.
        6. 멀티 스레드 및 멀티 프로세스 환경에서의 디버깅을 지원합니다.
        
        GDB는 기본 텍스트 기반 커맨드라인 인터페이스를 제공하며, 사용자가 그래픽 사용자 인터페이스(GUI)를 선호하는 경우
        DDD(Data Display Debugger), Eclipse, Visual Studio Code 등 다양한 IDE나 도구와 함께 사용할 수 있습니다.
        GDB를 사용하려면 소스 코드를 컴파일할 때 디버그 정보를 포함하도록 설정해야 합니다 (예를 들어, gcc에서는 `-g` 옵션을 사용).
      </pre>
    </div>
    <div id="scanf_string_matching">
      <a class="tag">scanf의 문자열 매칭</a>
      <pre>
        `scanf`는 C 언어에서 입력을 받기 위해 사용되는 함수입니다.
        문자열 매칭을 위해 서식 지정자(format specifier)를 사용하여 입력 형식과 매칭되는 데이터를 읽어 변수에 저장합니다.

        다음은 `scanf`와 문자열 매칭의 몇 가지 예입니다:
        1. 문자열 입력 받기:
        char str[50];
        scanf("%s", str);
        %s 서식 지정자를 사용하여 문자열을 읽어 들입니다.
        
        2. 정수 입력 받기:
        int num;
        scanf("%d", &num);
        %d 서식 지정자를 사용하여 정수를 읽어 들입니다.
        
        3. 실수 입력 받기:
        float num;
        scanf("%f", &num);
        %f 서식 지정자를 사용하여 실수를 읽어 들입니다.
        
        4. 공백이 있는 문자열 입력 받기:
        char str[50];
        scanf("%[^\n]s", str);
        [^\n] 서식 지정자를 사용하여 개행 문자가 나올 때까지 문자열을 읽어 들입니다.
        
        `scanf`는 입력 데이터를 서식 지정자와 일치하지 않으면 정상적으로 처리하지 못할 수 있으며, 이를 대처하기 위해 안전하게 입력을 처리하는 방법들이 준비되어 있습니다.
        (예: fgets, sscanf 등) 이러한 방법은 버퍼 오버플로우와 같은 문제를 예방하는 데 도움이 됩니다.
      </pre>
    </div>
    <div id="C_header_files">
      <a class="tag">C언어 헤더 파일</a>
      <pre>
        C 언어에서 헤더 파일은 주로 소스 파일들 사이에서 공유되는 함수 원형, 매크로 정의, 데이터 구조, 상수 및 글로벌 변수 선언 등을 포함하는 파일입니다.
        헤더 파일은 소스 파일에 `#include` 지시문을 사용하여 포함됩니다. 이를 통해 컴파일러는 헤더 파일에 있는 정보를 사용하여 해당 소스 파일의 코드를 정확히 컴파일 할 수 있습니다.

        헤더 파일은 보통 `.h` 확장자를 사용하며, 표준 C 라이브러리에 포함된 일반적인 헤더 파일들은 여러 가지가 있습니다. 예를 들어:
        `stdio.h`: 표준 입출력 기능(예: `printf`, `scanf` 등)을 제공합니다.
        `stdlib.h`: 메모리 관리, 프로세스 제어, 문자열 및 숫자 변환 등의 함수를 제공합니다.
        `string.h`: 문자열 처리 작업에 필요한 함수(예: `strcpy`, `strcmp`, `strcat` 등)를 제공합니다.
        `math.h`: 수학적 계산을 수행하는 함수(예: `sin`, `cos`, `sqrt` 등)를 제공합니다.
        
        헤더 파일은 프로젝트의 코드 중복을 줄이고, 함수 및 데이터 구조의 일관성을 유지하며, 코드의 모듈성을 향상시키는 데 도움이 됩니다.
        사용자 정의 헤더 파일도 작성하여 프로젝트 내에서 동일한 정보를 공유할 수 있습니다.
      </pre>
    </div>
    <div id="fopen_freopen">
      <a class="tag">fopen과 freopen</a>
      <pre>
        `fopen`과 `freopen`은 C 프로그래밍 언어에서 파일을 읽고 쓰기 위해 사용되는 두 가지 표준 라이브러리 함수입니다.
        이들 함수는 파일을 다루기 위한 주요 도구로, 파일 포인터를 반환합니다. 이제 두 함수의 차이점을 살펴보겠습니다.

        `fopen`:
        `fopen` 함수는 지정된 파일을 열고 파일 포인터를 반환합니다.
        파일을 열 때 사용할 수 있는 다양한 모드(읽기, 쓰기, 추가 등)가 있으며, 함수는 파일이 성공적으로 열린 경우에만 유효한 파일 포인터를 반환합니다.
        파일이 열리지 않으면 NULL 포인터가 반환됩니다.
        함수 원형은 다음과 같습니다.
        FILE *fopen(const char *filename, const char *mode);
        
        `freopen`:
        `freopen` 함수는 기존 파일 포인터가 참조하고 있는 파일을 닫고, 지정된 파일을 지정된 모드로 열어 기존 파일 포인터와 연결합니다.
        이 함수는 표준 입력(stdin), 표준 출력(stdout), 표준 오류(stderr)와 같은 파일 스트림을 다른 파일로 재지정할 때 유용합니다. 함수 원형은 다음과 같습니다.
        FILE *freopen(const char *filename, const char *mode, FILE *stream);
        
        `fopen`은 특정 파일을 지정된 모드로 열고, `freopen`은 기존 파일 스트림을 닫고 새 파일로 재지정하는 데 사용됩니다.
        이렇게 다른 파일로 리디렉션하는 기능 덕분에 `freopen`은 파일 스트림을 제어하는 데 더 많은 유연성을 제공합니다.
      </pre>
    </div>
    <div id="C_plus_plus_cout">
      <a class="tag">C++의 cout</a>
      <pre>
        C++의 `cout`은 "console output"의 줄임말로서, C++에서 표준 출력 스트림 (stdout)에 데이터를 출력하는 객체입니다.
         `cout`은 iostream 헤더 파일에 정의되어 있으며, C++의 표준 라이브러리인 `std` 네임스페이스에 속합니다. 따라서 `std::cout`의 형태로 사용됩니다.
        `cout`은 연산자 오버로딩 기능을 활용하여, 다양한 데이터 타입을 출력할 수 있습니다.
         &#60;&#60;` 연산자(스트림 삽입 연산자 혹은 출력 연산자라고도 함)를 사용하여, 출력할 데이터를 `std::cout` 객체에 전달합니다. 이후 출력이 완료되었다면, `std::endl` 또는 `'\n'`을 사용하여 줄 바꿈을 수행합니다.
        
        예를 들어, 정수 100을 출력하는 코드는 아래와 같습니다.
        #include <iostream>
        
        int main() {
            int number = 100;
        
            // 출력하기
            std::cout &#60;&#60; "Number: " &#60;&#60; number &#60;&#60; std::endl;
        
            return 0;
        }
        
        여기서 `std::cout &#60;&#60; "Number: " &#60;&#60; number &#60;&#60; std::endl;` 부분이 `cout`을 사용한 출력 부분입니다.
        문자열 "Number: "와 변수 `number`의 값(100)이 한 줄에 출력되며, 마지막에 줄 바꿈이 일어납니다.
      </pre>
    </div>
    <div id="Cin_printf_difference">
      <a class="tag">cin과 C의 printf, scanf와의 차이</a>
      <pre>
        `cin`, `printf` 및 `scanf`는 모두 C++ 및 C 프로그래밍 언어에서 사용되는 I/O(입출력) 함수입니다.
        그러나 그들은 구현 및 구성에 약간의 차이가 있습니다.

        cin:
        C++에서 제공하는 입출력 객체로, 표준 입력(주로 키보드)에서 값을 읽어 들입니다.
        연산자 `>>`(스트림 추출 연산자)와 함께 사용해서 변수에 값을 할당할 수 있습니다.
        `cin`은 표준 라이브러리 `iostream`에 정의되어 있습니다.
        사용 예: `int x; cin >> x;`
        
        printf:
        C 언어에서 제공하는 기본 출력 함수입니다. 포맷 문자열을 사용해 다양한 형식의 데이터를 출력할 수 있습니다.
        표준 라이브러리 `stdio.h`(C++) 또는 `cstdio`(C)에 정의되어 있습니다.
        사용 예: `int x = 10; printf("x = %d\n", x);`
        
        scanf:
        C 언어에서 제공하는 기본 입력 함수입니다. 포맷 문자열을 사용하여 다양한 형식의 데이터를 입력받을 수 있습니다.
        표준 라이브러리 `stdio.h`(C++) 또는 `cstdio`(C)에 정의되어 있습니다.
        사용 예: `int x; scanf("%d", &x);`
        
        차이점:
        `cin`은 C++에서 제공되며, `printf` 및 `scanf`는 C에서 제공됩니다.
        `cin`은 스트림 추출 연산자(`>>`)와 함께 사용되며, `printf`와 `scanf`는 포맷 문자열을 사용합니다.
        `cin`은 `iostream` 라이브러리에서 가져온 반면 `printf`와 `scanf`는 `stdio.h`(C++) 또는 `cstdio`(C)에서 가져옵니다.
      </pre>
    </div>
    <div id="pointer_reference_difference">
      <a class="tag">포인터(*)와 참조(&)의 차이</a>
      <pre>
        포인터와 참조는 C++에서 변수를 다루는 데 사용되는 개념입니다.
        두 개념 모두 변수에 대한 간접 참조를 지원하지만, 사용 방법과 용도에 차이가 있습니다.

        포인터(pointer, *):
        포인터는 변수의 메모리 주소값을 저장하는 변수입니다. 포인터 변수에 `*` 기호를 사용하여 선언하고, `&` 기호를 사용하여 다른 변수의 메모리 주소를 얻어서 저장합니다.
        포인터를 사용하면 동적 메모리 할당이 가능하고, 간접적으로 다른 변수를 조작할 수 있습니다.

        예시:
        int a = 10;
        int* p = &#38;a; // p는 a의 메모리 주소를 저장하는 포인터 변수입니다.
        
        참조(reference, &):
        참조는 기존 변수의 별명(alias)을 만드는 방법으로, 참조 변수를 선언할 때 `&` 기호를 사용합니다.
        참조는 기존 변수를 그대로 가리키며, 새로운 메모리를 할당하지 않으므로 참조 변수를 변경하면 원래 변수의 값도 변경됩니다.
          
        예시:
        int a = 10;
        int& r = a; // r은 a의 참조 변수이며, a의 별명(alias)입니다.
        
        포인터는 메모리 주소를 저장하는 변수이며, 참조는 기존 변수의 별명입니다. 포인터는 동적 메모리 할당에 유용하고, 참조는 원래 변수와 동일한 변수로 작업 할 때 사용합니다.
      </pre>
    </div>
    <div id="function_pointer_lambda">
      <a class="tag">함수 포인터와 람다(익명) 함수</a>
      <pre>
        함수 포인터와 람다(익명) 함수는 둘 다 개발자가 코드에서 함수를 취급하도록 도와주는 기능입니다.
        두 기능의 주요 차이점은 다음과 같습니다.

        함수 포인터(Function Pointer):
        함수 포인터는 함수의 메모리 상 주소를 저장하는 변수입니다.
        이를 이용해 다른 함수를 전달인자로 전달하거나, 반환 값으로 반환할 수 있습니다.
        C++에서는 함수 포인터를 다음과 같이 선언할 수 있습니다.
        
        int add(int a, int b) { return a + b; }
        
        int main() {
          int (*funcPtr)(int, int) = &#38;add; // add 함수의 주소를 가리키는 함수 포인터 funcPtr 선언
          int result = funcPtr(3, 4); // 함수 포인터를 사용해 add 함수 호출
        }
        
        람다(익명) 함수(Lambda, Anonymous Function): 람다 함수는 이름이 없는 함수로, 주로 일회성 작업이나 간단한 기능 구현에 사용됩니다.
        C++11부터 이 기능을 지원하기 시작했습니다. 람다 함수는 대괄호([])로 시작하며, 몸체 내에서 외부 변수를 접근하기 위해 캡처 목록을 사용할 수 있습니다.
        람다 함수의 정의 및 호출은 다음과 같습니다.
        
        int main() {
          auto lambdaFunc = [](int a, int b) { return a + b; }; // 람다 함수 정의 및 할당
          int result = lambdaFunc(3, 4); // 람다 함수 호출
        }
        
        함수 포인터는 함수의 주소를 변수에 저장하여 이용하는 방식이고 람다 함수는 이름 없이 일회성 또는 간단한 작업에 사용되는 익명 함수입니다.
      </pre>
    </div>
    <div id="callback_hell">
      <a class="tag">콜백 함수와 콜백 지옥</a>
      <pre>
        콜백 함수(callback function)란, 어떤 함수의 인자로 전달되어 실행되는 함수를 말합니다.
        이러한 콜백 함수를 사용하면, 코드의 흐름을 쉽게 구현할 수 있습니다. 특히 비동기 프로그래밍에서는 콜백 함수가 자주 사용됩니다.
        비동기 작업이 완료되었을 때, 호출되어야 할 함수를 콜백 함수로 전달하면 됩니다.

        그러나 콜백 함수의 사용이 과도하게 중첩될 경우, 콜백 지옥(callback hell)이 발생할 수 있습니다.
        콜백 지옥이란, 여러 개의 콜백 함수가 중첩되어 코드가 복잡하고 어려워지는 현상을 말합니다.
        이러한 콜백 지옥은 코드 가독성을 떨어뜨리고 오류 발생 가능성을 높입니다.
        
        콜백 지옥을 피하려면 다음과 같은 방법을 사용할 수 있습니다:
        1. 네임드 함수 사용: 무명 함수 대신 명명된(named) 함수를 사용하여 코드의 가독성을 높입니다.
        2. 비동기 제어 라이브러리 사용: async.js나 bluebird와 같은 비동기 제어 라이브러리를 사용하여, 코드의 복잡도를 줄입니다.
        3. Promises, async/await 사용: 자바스크립트의 Promises와 async/await를 사용하여 비동기 작업을 보다 명료하게 표현할 수 있습니다.
        
        현대적인 프로그래밍 언어들은 콜백 지옥을 해결할 수 있는 여러 가지 방법을 제공하고 있기 때문에, 적절한 기술을 사용하여 코드의 복잡성을 낮추면 됩니다.
      </pre>
    </div>
  </section>
  <aside></aside>
  <footer></footer>
</body>

</html>